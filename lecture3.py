# Функции, рекурсия, алгоритмы

# Создание и использование функции внутри Python:

# def function_name(x): 
# body line 1 
  # ... 
# body line n 
# optional return 

# !!! Сколько аргументов передаем, столько и принимаем. 
# !!! Сколько аргументов принимаем, столько и передаем. 

# Задание: 
# Необходимо создать функцию sumNumbers(n), которая будет считать сумму всех элементов от 1 до n.

def sumNumbers(n): 
    summa = 0 
    for i in range(1, n + 1): 
        summa += i 
    print(summa) 

n = int(input())        # 5 
sumNumbers(n)           # 15

# Либо используем return:
# 1. Завершает работу функции 
# 2. Возвращает значение

def sumNumbers(n): 
    summa = 0 
    for i in range(1, n + 1): 
        summa += i 
    return summa 

n = int(input())          # 5 
print(sumNumbers(n))      # 15



# Модульность
# Создание отдельных файлов, где находятся только функции, и эти функции при необходимости можно вызывать из главного файла.

# 1.	function_file.py 
# (Новый Python файл, в котором находятся функция f(x))

def f(x): 
    if x == 1: 
        return 'Целое'
    elif x == 2.3: 
        return 23 
    return           # выход из функции 

# 2.	working_file.py 

# Чтобы начать взаимодействовать с функцией в файле function_file.py необходимо добавить эту возможность к себе в программный код. 
# Сначала мы обращаемся к файлу (без расширения).
# С помощью import мы можем вызвать эту функцию в другом скрипте и дальше использовать её в новом файле. 
# Можно сократить название функции в рабочем файле с помощью команды:  Alias (псевдоним) — альтернативное имя, которое даётся функции при её импорте из файла.

import function_file 
print(function_file.f(1))      # Целое 
print(function_file.f(2.3))    # 23 
print(function_file.f(28))     # None

# Значения по умолчанию для функции 
# В Python можно перемножать строку на число. 

# В данной функции есть два аргумента: symbol (символ или число) и count (число, на которое умножается первый аргумент). 
# Если введены оба аргумента, функция работает без ошибок. Если только символ — функция выдает ошибку. 

def new_string(symbol, count):
    return symbol * count 
print(new_string('!', 5))         # !!!!! 
# print(new_string('!'))            # TypeError missing 1 required ... 


# Можно указать значение переменной count по умолчанию. 
# Например, если значение явно не указано (нет второго аргумента), по умолчанию значение переменной count равно трем. 

def new_string(symbol, count=3): 
    return symbol * count 
print(new_string('!', 5))         # !!!!! 
print(new_string('!'))            # !!! 
print(new_string(4))              # 12

# Возможность передачи неограниченного количества аргументов 
# ● Можно указать любое количество значений аргумента функции. 
# ● Перед аргументом надо поставить *. 
# В примере ниже функция работает со строкой, поэтому при введении чисел программа выдаёт ошибку:

def concatenatio(*params):
    res = "" 
    for item in params: 
        res += item 
    return res 

print(concatenatio('a', 's', 'd', 'w'))         # asdw 
print(concatenatio('a', '1'))                   # a1 
# print(concatenatio(1, 2, 3, 4))               # TypeError: ...


# Рекурсия — это функция, вызывающая сама себя. 
# При описании рекурсии важно указать, когда функции надо остановиться и перестать вызывать саму себя. По-другому говоря, необходимо указать базис рекурсии. 

# Пользователь вводит число n. Необходимо вывести n - первых членов последовательности Фибоначчи. 
# Последовательно Фибоначчи, это такая последовательность, в которой каждое последующее число равно сумме 2-ух предыдущих 
# Решение:

def fib(n):
    if n in [1, 2]: 
        return 1 
    return fib(n - 1) + fib(n - 2) 

list_1 = [] 
for i in range(1, 10): 
    list_1.append(fib(i - 2)) 
print(list_1)                                      # [1, 1, 2, 3, 5, 8, 13, 21, 34]


# Алгоритм - набор инструкций для выполнения некоторой задачи. 

# Алгоритмы сортировок:
# 1.	Быстрая сортировка 
# Стратегия «разделяй и властвуй» (алгоритм бинарного поиска)
# Пример: Два друга решили поиграть в игру: один загадывает число от 1 до 100, другой должен отгадать. 
# Обозначим друзей, друг_1 это Иван, который загадал число, друг_2 это Петр, который отгадывает. 
# Итак начнем: Иван загадал число 77. 
# Петр: Число больше 50? 
# Иван: Да. 
# Петр: Число больше 75? 
# Иван: Да. и т.д. пока не сузится диапазон.
# Число оказалось в диапазоне 76 < x < 78, значит это число 77.  Задача решена. 

def quicksort(array):
    if len(array) < 2: 
        return array
    else: 
        pivot = array[0] 
        less = [i for i in array[1:] if i <= pivot] 
        greater = [i for i in array[1:] if i > pivot] 
        return quicksort(less) + [pivot] + quicksort(greater) 
print(quicksort([10, 5, 2, 3]))

# 2.	Сортировка слиянием
def merge_sort(nums):
    if len(nums) > 1:
        mid = len(nums) // 2 
        left = nums[:mid] 
        right = nums[mid:] 
        merge_sort(left) 
        merge_sort(right) 
        i = j = k = 0 
        while i < len(left) and j < len(right): 
            if left[i] < right[j]: 
                nums[k] = left[i] 
                i += 1 
            else: 
                nums[k] = right[j] 
                j += 1 
            k += 1 
        while i < len(left):
            nums[k] = left[i] 
            i += 1 
            k += 1 
        while j < len(right): 
            nums[k] = right[j] 
            j += 1 
            k += 1 
nums = [38, 27, 43, 3, 9, 82, 10]
merge_sort(nums) 
print(nums)
